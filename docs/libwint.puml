@startuml



package libint #c6ffb3 {
    namespace libint2 #ffffff {
        class Atom {
            + atomic_number
            + x
            + y
            + z
        }

        class Engine {
            + const target_ptr_vec& **results**()
            + const Engine::target_ptr_vec& **calculate**()
        }

        class BasisSet {
            + size_type **size**()
            + long **nbf**()
            + size_t **max_nprim**()
            + long **max_l**()
            + const std::vector<size_t>& **shell2bf**()
        }

        class Operator {
            overlap
            kinetic
            nuclear
            coulomb
        }
    }
}




namespace libwint #ffffff {
    class global {
        .. Molecule ..
            std::vector<libint2::Atom> **parse_filename**(const std::string& filename)
        .. transformations ..
            Eigen::MatrixXd **transform_one_electron_integrals**(Eigen::MatrixXd& h, Eigen::MatrixXd& T)
            Eigen::Tensor<double, 4> **transform_two_electron_integrals**(Eigen::Tensor<double, 4>& g, Eigen::MatrixXd& T)

            Eigen::MatrixXd **transform_AO_to_SO**(Eigen::MatrixXd& f_AO, Eigen::MatrixXd& C)
            Eigen::MatrixXd **transform_SO_to_AO**(Eigen::MatrixXd& f_SO, Eigen::MatrixXd& C)
            Eigen::Tensor<double, 4> **transform_AO_to_SO**(Eigen::Tensor<double, 4>& g_AO, Eigen::MatrixXd& C)

            Eigen::MatrixXd **rotate_integrals**(Eigen::MatrixXd& h, Eigen::MatrixXd& U)
            Eigen::Tensor<double, 4> **rotate_integrals**(Eigen::Tensor<double, 4>& g, Eigen::MatrixXd& U)

            Eigen::MatrixXd **jacobi_rotation_matrix**(size_t P, size_t Q, double theta, size_t M)
            Eigen::MatrixXd **rotate_one_electron_integrals_jacobi**(Eigen::MatrixXd& h, size_t P, size_t Q, double theta)
            Eigen::MatrixXd **jacobi_rotation_matrix**(size_t P, size_t Q, double theta, size_t M)
            Eigen::MatrixXd **rotate_one_electron_integrals_jacobi**(Eigen::MatrixXd& h, size_t P, size_t Q, double theta)
    }

    class Basis {
        __ private members __
            - bool are_calculated_overlap_integrals
            - bool are_calculated_nuclear_integrals
            - bool are_calculated_kinetic_integrals
            - bool are_calculated_tei

            - libwint::Molecule& molecule
            - const std::string name

            - libint2::BasisSet& libint_basis

            + Eigen::MatrixXd S
            + Eigen::MatrixXd T
            + Eigen::MatrixXd V
            + Eigen::Tensor<double, 4> eri
        __ private methods __
           - Eigen::MatrixXd **calculateOneBodyIntegrals**(const libint2::Operator& opertype, const libint2::BasisSet& obs, const std::vector<libint2::Atom>& atoms)
           - Eigen::Tensor<double, 4> **calculateTwoElectronRepulsionIntegrals**(const libint2::BasisSet& obs, const std::vector<libint2::Atom>& atoms)
        == constructors ==
            Basis(Molecule& molecule, const std::string& basis_name)
        __ public methods __
            + Eigen::MatrixXd **get_S**()
            + Eigen::MatrixXd **get_T**()
            + Eigen::MatrixXd **get_V**()
            + Eigen::Tensor<double, 4> **get_eri**()

            + size_t **calculateNumBF**()
            + void **calculateOverlapIntegrals**()
            + void **calculateKineticIntegrals**()
            + void **calculateNuclearIntegrals**()
            + void **calculateTwoElectronIntegrals**()
            + void **calculateIntegrals**()
            + void **printShellSizes**()
    }


    class Molecule {
        __ private members __
            - std::vector<libint2::Atom> atoms
            - size_t N
            - const std::string xyz_filename
        __ private methods __
            - size_t **calculate_nucleic_charge**()
            - double **internuclear_distance**(const libint2::Atom& atom1, const libint2::Atom& atom2)
        == constructors ==
            Molecule(const std::string& xyz_filename)
            Molecule(const std::string& xyz_filename, int molecular_charge)
        __ public methods __
            + site_t **get_N**()

            + double **calculateInternuclearRepulsion**()
    }

}



libwint.Basis o--> libwint.Molecule
libwint.Basis *--> libint2.BasisSet
libwint.Basis ..> libint2.Operator
libwint.Basis *--> libint2.Engine

libwint.Molecule *--> "1..*" libint2.Atom







@enduml